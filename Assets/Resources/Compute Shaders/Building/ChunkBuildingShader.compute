#pragma kernel Main

struct voxel_triangle_data
{
    int x_front_side_index;    
    int x_back_side_index;
    int y_front_side_index;    
    int y_back_side_index;
    int z_front_side_index;    
    int z_back_side_index;
};

uint3 model_size;
uint3 chunk_size;
uint3 chunk_id;
float voxel_size;

StructuredBuffer<voxel_triangle_data> voxel_triangles_data;

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<int> triangles;

int get_voxel_index_in_chunk(int3 id)
{
    if (id.x >= chunk_size.x || id.y >= chunk_size.y || id.z >= chunk_size.z)
    {
        return -1;
    }

    return id.z * chunk_size.x * chunk_size.y + id.y * chunk_size.x + id.x;
}

bool is_in_model(uint3 id)
{
    bool is_valid = chunk_id.x * chunk_size.x + id.x < model_size.x;

    is_valid = is_valid && chunk_id.y * chunk_size.y + id.y < model_size.y;
    is_valid = is_valid && chunk_id.z * chunk_size.z + id.z < model_size.z;
    
    return is_valid;
}


void build_x_back_side(const uint index, const uint3 id, const float3 offset)
{
    const voxel_triangle_data data = voxel_triangles_data[index];
    const int side_index = data.x_back_side_index;
    if (side_index == -1) return;

    const float3 v1 = float3(voxel_size * id.x, voxel_size * id.y, voxel_size * id.z);
    const float3 v2 = float3(voxel_size * id.x, voxel_size * id.y, voxel_size * (id.z + 1));
    const float3 v3 = float3(voxel_size * id.x, voxel_size * (id.y + 1), voxel_size * (id.z + 1));
    const float3 v4 = float3(voxel_size * id.x, voxel_size * (id.y + 1), voxel_size * id.z);

    const int VERTICES_PER_SIDE = 4;
    const int TRIANGLE_VERTICES_PER_SIDE = 6;
    
    vertices[side_index * VERTICES_PER_SIDE] = v1 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 1] = v2 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 2] = v3 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 3] = v4 + offset;
    
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 1] = side_index * VERTICES_PER_SIDE + 1;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 2] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 3] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 4] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 5] = side_index * VERTICES_PER_SIDE + 3;
}

void build_x_front_side(const uint index, const uint3 id, const float3 offset)
{
    const voxel_triangle_data data = voxel_triangles_data[index];
    const int side_index = data.x_front_side_index;
    if (side_index == -1) return;
    
    const float3 v1 = float3(voxel_size * (id.x + 1), voxel_size * id.y, voxel_size * id.z);
    const float3 v2 = float3(voxel_size * (id.x + 1), voxel_size * id.y, voxel_size * (id.z + 1));
    const float3 v3 = float3(voxel_size * (id.x + 1), voxel_size * (id.y + 1), voxel_size * (id.z + 1));
    const float3 v4 = float3(voxel_size * (id.x + 1), voxel_size * (id.y + 1), voxel_size * id.z);

    const int VERTICES_PER_SIDE = 4;
    const int TRIANGLE_VERTICES_PER_SIDE = 6;
    
    vertices[side_index * VERTICES_PER_SIDE] = v1 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 1] = v2 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 2] = v3 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 3] = v4 + offset;

    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 1] = side_index * VERTICES_PER_SIDE + 3;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 2] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 3] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 4] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 5] = side_index * VERTICES_PER_SIDE + 1;
}

void build_y_back_side(const uint index, const uint3 id, const float3 offset)
{
    const voxel_triangle_data data = voxel_triangles_data[index];
    const int side_index = data.y_back_side_index;
    if (side_index == -1) return;

    const float3 v1 = float3(voxel_size * id.x, voxel_size * id.y, voxel_size * id.z);
    const float3 v2 = float3(voxel_size * id.x, voxel_size * id.y, voxel_size * (id.z + 1));
    const float3 v3 = float3(voxel_size * (id.x + 1), voxel_size * id.y, voxel_size * (id.z + 1));
    const float3 v4 = float3(voxel_size * (id.x + 1), voxel_size * id.y, voxel_size * id.z);

    const int VERTICES_PER_SIDE = 4;
    const int TRIANGLE_VERTICES_PER_SIDE = 6;
    
    vertices[side_index * VERTICES_PER_SIDE] = v1 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 1] = v2 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 2] = v3 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 3] = v4 + offset;
    
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 1] = side_index * VERTICES_PER_SIDE + 3;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 2] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 3] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 4] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 5] = side_index * VERTICES_PER_SIDE + 1;
}

void build_y_front_side(const uint index, const uint3 id, const float3 offset)
{
    const voxel_triangle_data data = voxel_triangles_data[index];
    const int side_index = data.y_front_side_index;
    if (side_index == -1) return;

    const float3 v1 = float3(voxel_size * id.x, voxel_size * (id.y + 1), voxel_size * id.z);
    const float3 v2 = float3(voxel_size * id.x, voxel_size * (id.y + 1), voxel_size * (id.z + 1));
    const float3 v3 = float3(voxel_size * (id.x + 1), voxel_size * (id.y + 1), voxel_size * (id.z + 1));
    const float3 v4 = float3(voxel_size * (id.x + 1), voxel_size * (id.y + 1), voxel_size * id.z);

    const int VERTICES_PER_SIDE = 4;
    const int TRIANGLE_VERTICES_PER_SIDE = 6;
    
    vertices[side_index * VERTICES_PER_SIDE] = v1 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 1] = v2 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 2] = v3 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 3] = v4 + offset;
    
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 1] = side_index * VERTICES_PER_SIDE + 1;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 2] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 3] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 4] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 5] = side_index * VERTICES_PER_SIDE + 3;
}

void build_z_back_side(const uint index, const uint3 id, const float3 offset)
{
    const voxel_triangle_data data = voxel_triangles_data[index];
    const int side_index = data.z_back_side_index;
    if (side_index == -1) return;

    const float3 v1 = float3(voxel_size * id.x, voxel_size * id.y, voxel_size * id.z);
    const float3 v2 = float3(voxel_size * id.x, voxel_size * (id.y + 1), voxel_size * id.z);
    const float3 v3 = float3(voxel_size * (id.x + 1), voxel_size * (id.y + 1), voxel_size * id.z);
    const float3 v4 = float3(voxel_size * (id.x + 1), voxel_size * id.y, voxel_size * id.z);

    const int VERTICES_PER_SIDE = 4;
    const int TRIANGLE_VERTICES_PER_SIDE = 6;
    
    vertices[side_index * VERTICES_PER_SIDE] = v1 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 1] = v2 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 2] = v3 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 3] = v4 + offset;
    
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 1] = side_index * VERTICES_PER_SIDE + 1;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 2] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 3] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 4] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 5] = side_index * VERTICES_PER_SIDE + 3;
}

void build_z_front_side(const uint index, const uint3 id, const float3 offset)
{
    const voxel_triangle_data data = voxel_triangles_data[index];
    const int side_index = data.z_front_side_index;
    if (side_index == -1) return;

    const float3 v1 = float3(voxel_size * id.x, voxel_size * id.y, voxel_size * (id.z + 1));
    const float3 v2 = float3(voxel_size * id.x, voxel_size * (id.y + 1), voxel_size * (id.z + 1));
    const float3 v3 = float3(voxel_size * (id.x + 1), voxel_size * (id.y + 1), voxel_size * (id.z + 1));
    const float3 v4 = float3(voxel_size * (id.x + 1), voxel_size * id.y, voxel_size * (id.z + 1));

    const int VERTICES_PER_SIDE = 4;
    const int TRIANGLE_VERTICES_PER_SIDE = 6;
    
    vertices[side_index * VERTICES_PER_SIDE] = v1 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 1] = v2 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 2] = v3 + offset;
    vertices[side_index * VERTICES_PER_SIDE + 3] = v4 + offset;
    
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 1] = side_index * VERTICES_PER_SIDE + 3;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 2] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 3] = side_index * VERTICES_PER_SIDE;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 4] = side_index * VERTICES_PER_SIDE + 2;
    triangles[side_index * TRIANGLE_VERTICES_PER_SIDE + 5] = side_index * VERTICES_PER_SIDE + 1;
}


void build_voxel(const uint index, const uint3 id)
{
    const float3 offset = -voxel_size * model_size / 2 + voxel_size * chunk_size * chunk_id;
    
    build_x_back_side(index, id, offset);
    build_x_front_side(index, id, offset);
    build_y_back_side(index, id, offset);
    build_y_front_side(index, id, offset);
    build_z_back_side(index, id, offset);
    build_z_front_side(index, id, offset);
}

[numthreads(10, 10, 10)]
void Main (uint3 id : SV_DispatchThreadID)
{
    const int index = get_voxel_index_in_chunk(id);
    
    if (index != -1 && is_in_model(id))
    {
        build_voxel(index, id);
    }
}
