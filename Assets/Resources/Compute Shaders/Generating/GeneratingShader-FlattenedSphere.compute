#pragma kernel Main

struct voxel
{
    int exists;
};

int3 model_size;
float voxel_size;
RWStructuredBuffer<voxel> voxels;

int get_voxel_index(int3 id)
{
    if (id.x >= model_size.x || id.y >= model_size.y || id.z >= model_size.z)
    {
        return -1;
    }

    return id.z * model_size.x * model_size.y + id.y * model_size.x + id.x;
}

float get_squared(float x)
{
    return x * x;
}

bool is_in_ellipse(uint3 id)
{
    const float3 offset = -voxel_size * model_size / 2;
    
    const float3 ellipse_coordinates = float3(0, 0, 0);

    const float3 voxel_coordinates = float3(
        id.x * voxel_size + voxel_size / 2.0,
        id.y * voxel_size + voxel_size / 2.0,
        id.z * voxel_size + voxel_size / 2.0) + offset;

    const float a = voxel_size * model_size.x / 2.0;
    const float b = voxel_size * model_size.y / 4.0;
    const float c = voxel_size * model_size.z / 2.0;
    
    return get_squared(voxel_coordinates.x - ellipse_coordinates.x) / (a * a)
        + get_squared(voxel_coordinates.y - ellipse_coordinates.y) / (b * b)
        + get_squared(voxel_coordinates.z - ellipse_coordinates.z) / (c * c) <= 1.0;
}

[numthreads(10, 10, 10)]
void Main (uint3 id : SV_DispatchThreadID)
{
    const int index = get_voxel_index(id);
    
    if (index != -1)
    {
        if (is_in_ellipse(id))
        {
            voxels[index].exists = 1;
        }
        else
        {
            voxels[index].exists = 0;
        }
    }
}