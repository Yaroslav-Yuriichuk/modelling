#pragma kernel Main

struct voxel
{
    int exists;
};

uint3 model_size;
uint3 chunk_size;
uint3 chunk_id;
float voxel_size;

RWStructuredBuffer<voxel> voxels;

float3 intrusion_point;
float intrusion_strength;

int get_voxel_index_in_chunk(const uint3 id)
{
    if (id.x >= chunk_size.x || id.y >= chunk_size.y || id.z >= chunk_size.z)
    {
        return -1;
    }

    return id.z * chunk_size.x * chunk_size.y + id.y * chunk_size.x + id.x;
}

bool is_in_model(const uint3 id)
{
    bool is_valid = chunk_id.x * chunk_size.x + id.x < model_size.x;

    is_valid = is_valid && chunk_id.y * chunk_size.y + id.y < model_size.y;
    is_valid = is_valid && chunk_id.z * chunk_size.z + id.z < model_size.z;
    
    return is_valid;
}

bool is_in_intrusion_zone(const uint3 id)
{
    const float3 offset = -voxel_size * model_size / 2 + voxel_size * chunk_size * chunk_id;
    const float3 voxel_coordinates = float3(
        id.x * voxel_size + voxel_size / 2.0,
        id.y * voxel_size + voxel_size / 2.0,
        id.z * voxel_size + voxel_size / 2.0) + offset;

    bool is_inside;

    is_inside = (intrusion_point.x - intrusion_strength / 2 - voxel_coordinates.x)
        * (intrusion_point.x + intrusion_strength / 2 - voxel_coordinates.x) < 0;

    is_inside = is_inside && (intrusion_point.y - intrusion_strength / 2 - voxel_coordinates.y)
        * (intrusion_point.y + intrusion_strength / 2 - voxel_coordinates.y) < 0;

    is_inside = is_inside && (intrusion_point.z - intrusion_strength / 2 - voxel_coordinates.z)
        * (intrusion_point.z + intrusion_strength / 2 - voxel_coordinates.z) < 0;
    
    return is_inside;
}

void intrude_voxel(const uint index, const uint3 id)
{
    if (is_in_intrusion_zone(id))
    {
        voxels[index].exists = 0;
    }
}

[numthreads(10, 10, 10)]
void Main (uint3 id : SV_DispatchThreadID)
{
    const int index = get_voxel_index_in_chunk(id);

    if (index != -1 && is_in_model(id))
    {
        intrude_voxel(index, id);
    }
}
